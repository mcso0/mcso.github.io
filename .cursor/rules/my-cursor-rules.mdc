---
description: 
globs: 
alwaysApply: true
---
Remix React Router TypeScript Supabase
You are an expert in TypeScript, Node.js, React Router, React, Remix, Shadcn UI, Radix UI, Tailwind and Supabase.

Key Principles

- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported component, subcomponents, helpers, static content, types.

Naming Conventions

- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for components.

TypeScript Usage

- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use maps instead.
- Use functional components with TypeScript interfaces.

Syntax and Formatting

- Use the "function" keyword for pure functions.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.
- Use declarative JSX.

UI and Styling

- Use Shadcn UI, Radix, and Tailwind for components and styling.

Key Conventions

- Don't import anything from Radix UI. Always import from Shadcn UI.
- Don't import anything from Remix. Any @remix-run import should be imported from "react-router".
- When creating a new page always export a loader, action, and meta function.
- Route types should be imported like this: `import type { Route } from "./+types/my-route";` (파일명 맞춤)
- `useLoaderData` does not exist anymore. Instead, components receive Router.ComponentProps type param that contains loaderData.
- `useActionData` does not exist anymore. Instead, components receive Router.ComponentProps type param that contains actionData.
- Never use `useLoaderData` or `useActionData` in page components.
- `loader` function takes a Route.LoaderArgs type param.
- `action` function takes a Route.ActionArgs type param.
- `meta` function takes a Route.MetaFunction type param.
- `meta` returns MetaFunction type.
- `json` does not exists anymore. Return plain objects i.e `export function loader({ request }: Route.LoaderArgs) { return { } }`
- Use `data` when returning a response with a status code, otherwise return plain objects.
- `meta` function returns `MetaDescriptor[]` array, not single MetaFunction.
- ErrorBoundary and HydrateFallback components also receive Route.ComponentProps.
- tsconfig.json should include `.react-router/types/**/*` in include array for type generation.
- Use `useFetcher<typeof loader>()` instead of `useFetcher<LoaderData>()` for better type inference.

Component Organization

- Follow feature-based structure: `app/features/[feature]/components/[component].tsx`
- Place shared components in `app/common/components/`
- Create reusable UI components in `app/common/components/ui/`
- Extract complex components into separate files rather than inline components

Props and Interfaces

- Always define TypeScript interfaces for component props
- Use descriptive prop names that clearly indicate their purpose
- Prefer explicit prop drilling over complex state management for simple cases
- Use optional props with default values when appropriate: `title?: string`

Array Rendering and Keys

- Always provide unique `key` prop when rendering arrays: `key={item.id}` or `key={index}` 
- Use `Array.from({ length: n })` for generating fixed-length arrays
- Prefer `map()` over `for` loops for JSX rendering
- Use descriptive variable names in map callbacks: `users.map(user => ...)` not `users.map(u => ...)`

Layout and Styling

- Use CSS Grid (`grid`, `grid-cols-*`) for 2D layouts
- Use Flexbox (`flex`) for 1D layouts
- Always include `gap-*` classes with grid/flex layouts for spacing
- Use responsive classes: `grid-cols-1 md:grid-cols-2 lg:grid-cols-3`
- Prefer Tailwind utility classes over custom CSS

Data and State Management

- Keep component state as close to where it's used as possible
- Use meaningful variable names for state: `isLoading`, `hasError`, `selectedUser`
- Prefer controlled components over uncontrolled components
- Use React Router loaders for data fetching instead of useEffect

File Structure Best Practices

- Group related files together in feature directories
- Keep components small and focused on single responsibility
- Use barrel exports (index.ts) for cleaner imports
- Place types and interfaces close to where they're used

항상 한국어로 답변해줘.